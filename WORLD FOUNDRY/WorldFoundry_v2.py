# This filter is for casting Worlds from the raw potential of code
# abrightmoore@yahoo.com.au
# http://brightmoore.net
# My filters may include code and inspiration from PYMCLEVEL/MCEDIT mentors @Texelelf, @Sethbling, @CodeWarrior0, @Podshot_

from pymclevel import TAG_String # @Texelelf
from pymclevel import TileEntity # @Texelelf

import time # for timing
from math import sqrt, tan, sin, cos, pi, ceil, floor, acos, atan, asin, degrees, radians, log, atan2
from random import *
from numpy import *
from pymclevel import alphaMaterials, MCSchematic, MCLevel, BoundingBox, MCMaterials
from mcplatform import *
from os import listdir
from os.path import isfile, join
import glob
from pymclevel import TAG_List, TAG_Byte, TAG_Int, TAG_Compound, TAG_Short, TAG_Float, TAG_Double, TAG_String, TAG_Long
# import from @Texelelf
from copy import deepcopy
import bresenham # @Codewarrior0
from random import Random # @Codewarrior0
import inspect # @Texelelf
from PIL import Image
import png

# GLOBAL
CHUNKSIZE = 16

# Filter pseudocode:
#

inputs = (
		("World Foundry", "label"),
		("Divisions:", 30),
		("Radius:",50),
		("Wiggle:",6),
		("Ocean:", False),
		("Core:", False),		
		("Operation:", (
			"Geometry",
			"Wireframe",
  		    )),

		("Seed:", 1),
		("abrightmoore@yahoo.com.au", "label"),
		("http://brightmoore.net", "label"),
)

def createSign(level, x, y, z, text): #abrightmoore - convenience method. Due to Jigarbov - this is not a Sign.
	ALIASKEY = "WORLD NUMBER"
	COMMANDBLOCK = 137
	CHUNKSIZE = 16
	STANDING_SIGN = 63
	
	setBlock(level, (STANDING_SIGN,8), x, y, z)
	setBlock(level, (1,0), x, y-1, z)
	control = TAG_Compound()
	control["id"] = TAG_String("Sign")
	control["Text1"] = TAG_String(ALIASKEY)
	control["Text2"] = TAG_String(text)
	control["Text3"] = TAG_String("Generated by")
	control["Text4"] = TAG_String("@abrightmoore")	
	
	control["x"] = TAG_Int(x)
	control["y"] = TAG_Int(y)
	control["z"] = TAG_Int(z)
	chunka = level.getChunk((int)(x/CHUNKSIZE), (int)(z/CHUNKSIZE))
	chunka.TileEntities.append(control)
	chunka.dirty = True

def worldGeometry(RAND, BASERADIUS, DIVISIONS, WIGGLE):
	ANGLEDELTA = 2*pi/(DIVISIONS+1)
	OFFSETANGLELAT = pi/DIVISIONS
	ANGLEDELTALAT = (pi-OFFSETANGLELAT*2)/DIVISIONS
	aWorld = [[BASERADIUS+RAND.randint(-WIGGLE,WIGGLE) for x in range(DIVISIONS)] for x in range(DIVISIONS)]
	
	for i in range(RAND.randint(0,DIVISIONS)):
		x = RAND.randint(0,DIVISIONS-1)
		y = RAND.randint(0,DIVISIONS-1)
		aWorld[x][y] = aWorld[x][y]-RAND.randint(1,WIGGLE)

	return aWorld

def worldBuilder(level,box,options):
	method = "worldBuilder"
	(method, (width, height, depth), (centreWidth, centreHeight, centreDepth)) = FuncStart(level,box,options,method)	
	print "Seed:"
	PARAM = int(options["Seed:"])
	if PARAM == 0:
		PARAM = randint(0,99999999999)
	print PARAM
	RAND = Random(PARAM)

	# MAXWIGGLE = 8
	
	R = centreWidth
	if centreHeight < R:
		R= centreHeight
	if centreDepth < R:
		R= centreDepth
	
	
	DIVISIONS = options["Divisions:"]
	if DIVISIONS < 3:
		DIVISIONS = RAND.randint(30,100)
	BASERADIUS = options["Radius:"] # R-MAXWIGGLE-RAND.randint(0,int(R/3))
	if BASERADIUS < 1:
		BASERADIUS = R-MAXWIGGLE-RAND.randint(0,int(R/3))
	WIGGLE = options["Wiggle:"]
	if WIGGLE < 1:
		WIGGLE = RAND.randint(2,MAXWIGGLE)
	OPERATION = options["Operation:"]
	
	if OPERATION == "Wireframe":
		materialFill = (0,0) # AIR
	
	# A world is a planet spheroid defined by a bunch of altitudes from the centre
	aWorld = worldGeometry(RAND, BASERADIUS, DIVISIONS, WIGGLE)
	
	# plot the world in the selection box
	cx = centreWidth
	cy = centreHeight
	cz = centreDepth
	
	ANGLEDELTA = 2*pi/(DIVISIONS+1)
	OFFSETANGLELAT = pi/DIVISIONS
	ANGLEDELTALAT = (pi-OFFSETANGLELAT*2)/DIVISIONS
	aWorldWiggle = [[RAND.randint(-1,1)*ANGLEDELTALAT/3 for x in range(DIVISIONS)] for x in range(DIVISIONS)]

	palette = []
	palette.append( [ (1,0),(1,1), (1,2), (1,3), (1,4), (1,5), (1,6), (80,0) ] )
	palette.append( [ (95,3),(22,0), (24,2), (19,0), (18,0), (3,0), (1,0), (80,0) ]	)

	colours = "15 7 8 0 6 2 10 11 3 9 13 5 4 1 14 12".split() # I like this sequence
	coloursList = map(int, colours)
	coloursListLen = len(coloursList)
	RAND2 = Random(42)
	
	# Choose a colour pallette
	print 'Pallette Selection'

	for i in range(32):
		gap = RAND2.randint(1,4)
		newCols = []
		baseIndex = RAND2.randint(0,coloursListLen)

		for j in range(8):
			newCols.append( (159, (int)(coloursList[(baseIndex+j*gap)%coloursListLen]) ) )
		palette.append(newCols)
	for i in range(8):
		gap = RAND2.randint(1,4)
		newCols = []
		baseIndex = RAND2.randint(0,coloursListLen)

		for j in range(8):
			newCols.append( (95, (int)(coloursList[(baseIndex+j*gap)%coloursListLen]) ) )
		palette.append(newCols)

	palette.append( [ (11,0),(11,0), (11,0), (11,0), (11,0), (11,0), (11,0), (11,0) ]	) # Lava
	palette.append( [ (49,0),(11,0), (11,0), (11,0), (11,0), (11,0), (11,0), (11,0) ]	) # Lava with Obsidian base

	print 'Pallette Selection complete'
	blocks = palette[PARAM%len(palette)]
	print blocks
	
	print "Forging the planet..."
	
	# do the top and bottom bit
	NorthPole = BASERADIUS+RAND.randint(-WIGGLE,WIGGLE)
	SouthPole = BASERADIUS+RAND.randint(-WIGGLE,WIGGLE)

	for longitude in xrange(0,DIVISIONS+1): # http://www.bbc.co.uk/staticarchive/e344e73982934a546e4c9909087547478672e9ad.png
		if longitude%10 == 0:
			print longitude
		
		for latitude in xrange(0,DIVISIONS):
			longAngle1 = ANGLEDELTA * longitude + aWorldWiggle[longitude%DIVISIONS][(latitude)%DIVISIONS]
			latAngle1 = -pi/2+OFFSETANGLELAT+ANGLEDELTALAT * latitude + aWorldWiggle[longitude%DIVISIONS][(latitude)%DIVISIONS]
			longAngle2 = ANGLEDELTA * (longitude+1) + aWorldWiggle[(longitude+1)%DIVISIONS][(latitude)]
			latAngle2 = -pi/2+OFFSETANGLELAT+ANGLEDELTALAT * (latitude+1) + aWorldWiggle[longitude%DIVISIONS][(latitude+1)%DIVISIONS]

			
			(x1,z1,y1) = ((aWorld[(longitude)%DIVISIONS][(latitude)%DIVISIONS] * cos(longAngle1) * cos(latAngle1) ),
						  (aWorld[(longitude)%DIVISIONS][(latitude)%DIVISIONS] * sin(longAngle1) * cos(latAngle1) ),
						  (aWorld[(longitude)%DIVISIONS][(latitude)%DIVISIONS] * sin(latAngle1) ))
			(x2,z2,y2) = ((aWorld[(longitude)%DIVISIONS][(latitude+1)%DIVISIONS] * cos(longAngle1) * cos(latAngle2) ),
						  (aWorld[(longitude)%DIVISIONS][(latitude+1)%DIVISIONS] * sin(longAngle1) * cos(latAngle2) ),
						  (aWorld[(longitude)%DIVISIONS][(latitude+1)%DIVISIONS] * sin(latAngle2) ))
			(x3,z3,y3) = ((aWorld[(longitude+1)%DIVISIONS][(latitude+1)%DIVISIONS] * cos(longAngle2) * cos(latAngle2) ),
						  (aWorld[(longitude+1)%DIVISIONS][(latitude+1)%DIVISIONS] * sin(longAngle2) * cos(latAngle2) ),
						  (aWorld[(longitude+1)%DIVISIONS][(latitude+1)%DIVISIONS] * sin(latAngle2) ))
			(x4,z4,y4) = ((aWorld[(longitude+1)%DIVISIONS][(latitude)%DIVISIONS] * cos(longAngle2) * cos(latAngle1) ),
						  (aWorld[(longitude+1)%DIVISIONS][(latitude)%DIVISIONS] * sin(longAngle2) * cos(latAngle1) ),
						  (aWorld[(longitude+1)%DIVISIONS][(latitude)%DIVISIONS] * sin(latAngle1) ))
			(x0,z0,y0) = ((x1+x2+x3+x4)/4,(z1+z2+z3+z4)/4,(y1+y2+y3+y4)/4)

			if OPERATION == "Wireframe":
				drawTriangleEdge(level, box, options, (cx+x1,cy+y1,cz+z1),(cx+x2,cy+y2,cz+z2),(cx+x0,cy+y0,cz+z0), blocks[PARAM%len(blocks)])
				drawTriangleEdge(level, box, options, (cx+x2,cy+y2,cz+z2),(cx+x3,cy+y3,cz+z3),(cx+x0,cy+y0,cz+z0), blocks[PARAM%len(blocks)])
				drawTriangleEdge(level, box, options, (cx+x3,cy+y3,cz+z3),(cx+x4,cy+y4,cz+z4),(cx+x0,cy+y0,cz+z0), blocks[PARAM%len(blocks)])
				drawTriangleEdge(level, box, options, (cx+x4,cy+y4,cz+z4),(cx+x1,cy+y1,cz+z1),(cx+x0,cy+y0,cz+z0), blocks[PARAM%len(blocks)])
				
			else:	
				drawTriangleColour(level, box, options, (0,0,0), (cx+x1,cy+y1,cz+z1),(cx+x2,cy+y2,cz+z2),(cx+x0,cy+y0,cz+z0), blocks, (cx,cy,cz), BASERADIUS)
				drawTriangleColour(level, box, options, (0,0,0), (cx+x2,cy+y2,cz+z2),(cx+x3,cy+y3,cz+z3),(cx+x0,cy+y0,cz+z0), blocks, (cx,cy,cz), BASERADIUS)
				drawTriangleColour(level, box, options, (0,0,0), (cx+x3,cy+y3,cz+z3),(cx+x4,cy+y4,cz+z4),(cx+x0,cy+y0,cz+z0), blocks, (cx,cy,cz), BASERADIUS)
				drawTriangleColour(level, box, options, (0,0,0), (cx+x4,cy+y4,cz+z4),(cx+x1,cy+y1,cz+z1),(cx+x0,cy+y0,cz+z0), blocks, (cx,cy,cz), BASERADIUS)
			
				if latitude == 0: # South pole
					latAngle3 = -pi/2
					R2 = SouthPole
					(x5,z5,y5) = ((R2 * cos(longAngle1) * cos(latAngle3) ),
							  (R2 * sin(longAngle1) * cos(latAngle3) ),
							  (R2 * sin(latAngle3) ))
					drawTriangleColour(level, box, options, (0,0,0),(cx+x2,cy+y2,cz+z2),(cx+x3,cy+y3,cz+z3),(cx+x5,cy+y5,cz+z5), blocks, (cx,cy,cz), BASERADIUS)

				if latitude == DIVISIONS-1:
					latAngle3 = pi/2
					R2 = NorthPole
					(x5,z5,y5) = ((R2 * cos(longAngle2) * cos(latAngle3) ),
							  (R2 * sin(longAngle2) * cos(latAngle3) ),
							  (R2 * sin(latAngle3) ))
					drawTriangleColour(level, box, options, (0,0,0),(cx+x1,cy+y1,cz+z1),(cx+x4,cy+y4,cz+z4),(cx+x5,cy+y5,cz+z5), blocks, (cx,cy,cz), BASERADIUS)
	
	if options["Ocean:"] == True:
		print "Ocean..."
		for y in xrange(0,height):
			if y%10 == 0:
				print y
			for z in xrange(0,depth):
				for x in xrange(0,width):
					dx = x-cx
					dy = y-cy
					dz = z-cz
					dist = sqrt(dx*dx+dy*dy+dz*dz)
					if dist < BASERADIUS and dist >= BASERADIUS-WIGGLE:
						block = getBlock(level,x,y,z)
						if block == (0,0): # AIR
							setBlock(level,blocks[0],x,y,z)

	if options["Core:"] == True:
		print "Core..."
		for y in xrange(0,height):
			if y%10 == 0:
				print y
			for z in xrange(0,depth):
				for x in xrange(0,width):
					dx = x-cx
					dy = y-cy
					dz = z-cz
					dist = sqrt(dx*dx+dy*dy+dz*dz)
					if dist <= BASERADIUS-WIGGLE:
						block = getBlock(level,x,y,z)
						if block == (0,0): # AIR
							if RAND.randint(0,100) < 10:
								setBlock(level,blocks[RAND.randint(0,len(blocks)-1)],x,y,z)
							else:
								setBlock(level,blocks[int(dist)%len(blocks)],x,y,z)

							
	createSign(level, cx, cy, cz, str(PARAM))
	
	FuncEnd(level,box,options,method)

def drawTriangleColour(level, box, options, (ox, oy, oz), (p1x, p1y, p1z), (p2x, p2y, p2z), (p3x, p3y, p3z), blocks, centre, radius):
	# for each step along the 'base' draw a line from the apex
	dx = p3x - p2x
	dy = p3y - p2y
	dz = p3z - p2z

	distHoriz = dx*dx + dz*dz
	distance = sqrt(dy*dy + distHoriz)
	
	phi = atan2(dy, sqrt(distHoriz))
	theta = atan2(dz, dx)

	iter = 0
	while iter <= distance:
		(px, py, pz) = ((int)(p2x+iter*cos(theta)*cos(phi)), (int)(p2y+iter*sin(phi)), (int)(p2z+iter*sin(theta)*cos(phi)))
		iter = iter+0.5 # slightly oversample because I lack faith.
		drawLineColour(level, (ox+px, oy+py, oz+pz), (ox+p1x, oy+p1y, oz+p1z), blocks, centre, radius )	

def drawTriangleEdge(level, box, options, (p1x, p1y, p1z), (p2x, p2y, p2z), (p3x, p3y, p3z), materialEdge):
	drawLine(level, materialEdge, (p1x, p1y, p1z), (p2x, p2y, p2z) )
	drawLine(level, materialEdge, (p1x, p1y, p1z), (p3x, p3y, p3z) )
	drawLine(level, materialEdge, (p2x, p2y, p2z), (p3x, p3y, p3z) )
		
def perform(originalLevel,originalBox, options):
	''' Feedback to abrightmoore@yahoo.com.au '''
	# Local variables
	method = "Perform"
	(method, (width, height, depth), (centreWidth, centreHeight, centreDepth)) = FuncStart(originalLevel,originalBox,options,method) # Log start
	SUCCESS = True
	level = originalLevel.extractSchematic(originalBox) # Working set
	box = BoundingBox((0,0,0),(width,height,depth))
	# Operations go here - switch to the function based on selected operation
	worldBuilder(level, box, options)
		
		# Conditionally copy back the working area into the world
	if SUCCESS == True: # Copy from work area back into the world
		b=range(4096); b.remove(0) # @CodeWarrior0 and @Wout12345 explained how to merge schematics			
		originalLevel.copyBlocksFrom(level, box, (originalBox.minx, originalBox.miny, originalBox.minz ),b)
		originalLevel.markDirtyBox(originalBox)

	FuncEnd(originalLevel,box,options,method) # Log end	
	
	
	
####################################### CLASSES	



	
####################################### LIBS
	
def FuncStart(level, box, options, method):
	# abrightmoore -> shim to prepare a function.
	print '%s: Started at %s' % (method, time.ctime())
	(width, height, depth) = (box.maxx - box.minx, box.maxy - box.miny, box.maxz - box.minz)
	centreWidth = math.floor(width / 2)
	centreHeight = math.floor(height / 2)
	centreDepth = math.floor(depth / 2)	
	# other initialisation methods go here
	return (method, (width, height, depth), (centreWidth, centreHeight, centreDepth))

def FuncEnd(level, box, options, method):
	print '%s: Ended at %s' % (method, time.ctime())
	
def getBoxSize(box):
	return (box.maxx - box.minx, box.maxy - box.miny, box.maxz - box.minz)

def getBlock(level,x,y,z):
	return (level.blockAt(x,y,z), level.blockDataAt(x,y,z))

def setBlock(level, (block, data), x, y, z):
	level.setBlockAt(int(x), int(y), int(z), block)
	level.setBlockDataAt(int(x), int(y), int(z), data)
	
# Ye Olde GFX Libraries
def drawLine(scratchpad, (blockID, blockData), (x,y,z), (x1,y1,z1) ):
	drawLineConstrained(scratchpad, (blockID, blockData), (x,y,z), (x1,y1,z1), 0 )

def drawLineColour(scratchpad, (x,y,z), (x1,y1,z1), blocks, centre, radius ):
	drawLineConstrainedColour(scratchpad, (x,y,z), (x1,y1,z1), 0, blocks, centre, radius )

	
def drawLine1(scratchpad, (blockID, blockData), (x,y,z), (x1,y1,z1) ):
	for px, py, pz in bresenham.bresenham((x,y,z),(x1,y1,z1)):
		setBlock(scratchpad,(blockID, blockData),px,py,pz)
	setBlock(scratchpad,(blockID, blockData),x1,y1,z1)
	
def drawLineConstrainedColour(level, (x,y,z), (x1,y1,z1), maxLength, blocks, (cx,cy,cz), BASERADIUS ):
	dx = x1 - x
	dy = y1 - y
	dz = z1 - z

	distHoriz = dx*dx + dz*dz
	distance = sqrt(dy*dy + distHoriz)

	if distance < maxLength or maxLength < 1:
		phi = atan2(dy, sqrt(distHoriz))
		theta = atan2(dz, dx)
		px = 0
		py = 0
		pz = 0
		ddx = 0
		ddy = 0
		ddz = 0
		
		iter = 0
		while iter <= distance:
			ix = (int)(x+iter*cos(theta)*cos(phi))
			iy = (int)(y+iter*sin(phi))
			iz = (int)(z+iter*sin(theta)*cos(phi))

			ddx = ix-cx
			ddy = iy-cy
			ddz = iz-cz

			dist = sqrt(ddx*ddx+ddy*ddy+ddz*ddz)
			if dist < BASERADIUS-1:
				setBlock(level,blocks[0],ix,iy,iz) # Sea
			elif dist < BASERADIUS:
				setBlock(level,blocks[1],ix,iy,iz) # Lapis
			elif dist < BASERADIUS+1:
				setBlock(level,blocks[2],ix,iy,iz) # Sand
			elif dist < BASERADIUS+2:
				setBlock(level,blocks[3],ix,iy,iz) # Plain
			elif dist < BASERADIUS+3:
				setBlock(level,blocks[4],ix,iy,iz) # Forest
			elif dist < BASERADIUS+4:
				setBlock(level,blocks[5],ix,iy,iz) # Mt
			elif dist < BASERADIUS+5:
				setBlock(level,blocks[6],ix,iy,iz) # Snow
			elif dist >= BASERADIUS+5:
				setBlock(level,blocks[7],ix,iy,iz) # Snow
			iter = iter+0.5 # slightly oversample because I lack faith.

def drawLineConstrained(scratchpad, (blockID, blockData), (x,y,z), (x1,y1,z1), maxLength ):
	dx = x1 - x
	dy = y1 - y
	dz = z1 - z

	distHoriz = dx*dx + dz*dz
	distance = sqrt(dy*dy + distHoriz)

	if distance < maxLength or maxLength < 1:
		phi = atan2(dy, sqrt(distHoriz))
		theta = atan2(dz, dx)

		iter = 0
		while iter <= distance:
			scratchpad.setBlockAt((int)(x+iter*cos(theta)*cos(phi)), (int)(y+iter*sin(phi)), (int)(z+iter*sin(theta)*cos(phi)), blockID)
			scratchpad.setBlockDataAt((int)(x+iter*cos(theta)*cos(phi)), (int)(y+iter*sin(phi)), (int)(z+iter*sin(theta)*cos(phi)), blockData)
			iter = iter+0.5 # slightly oversample because I lack faith.

			
def drawLineConstrainedRandom(scratchpad, (blockID, blockData), (x,y,z), (x1,y1,z1), frequency ):
	dx = x1 - x
	dy = y1 - y
	dz = z1 - z

	distHoriz = dx*dx + dz*dz
	distance = sqrt(dy*dy + distHoriz)


	phi = atan2(dy, sqrt(distHoriz))
	theta = atan2(dz, dx)

	iter = 0
	while iter <= distance:
		if randint(0,99) < frequency:
			scratchpad.setBlockAt((int)(x+iter*cos(theta)*cos(phi)), (int)(y+iter*sin(phi)), (int)(z+iter*sin(theta)*cos(phi)), blockID)
			scratchpad.setBlockDataAt((int)(x+iter*cos(theta)*cos(phi)), (int)(y+iter*sin(phi)), (int)(z+iter*sin(theta)*cos(phi)), blockData)
		iter = iter+0.5 # slightly oversample because I lack faith.
